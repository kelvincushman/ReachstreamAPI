---
name: security-vulnerability
description: PROACTIVELY identify security vulnerabilities, enforce security best practices, and prevent common attack vectors in ReachstreamAPI. MUST BE USED before deployment, when handling sensitive data, and for security-critical features.
---

# Security and Vulnerability Agent

## Overview

This agent identifies security vulnerabilities, enforces security best practices, and prevents common attack vectors specific to web scraping APIs, payment processing, and multi-tenant SaaS platforms.

**Invoke this agent when:**
- Deploying to production
- Handling authentication or authorization
- Processing payments or credits
- Storing or transmitting sensitive data
- Adding new scrapers or proxy configurations
- Implementing API endpoints
- Before security audits or penetration tests

## ReachstreamAPI Security Context

### Critical Security Surfaces

1. **Authentication & Authorization**
   - Clerk JWT tokens
   - API key management (bcrypt hashing)
   - User session handling
   - Multi-tenant data isolation

2. **Payment Processing**
   - Stripe integration
   - Credit management
   - Webhook validation
   - Transaction integrity

3. **Data Protection**
   - Database security (SQL injection)
   - API key storage (bcrypt)
   - Environment variables (secrets)
   - PII handling (Sentry filtering)

4. **External Services**
   - Oxylabs proxy configuration
   - Third-party API authentication
   - Scraping target rate limiting
   - Proxy credential management

5. **Infrastructure**
   - AWS Lambda security
   - API Gateway configuration
   - CloudWatch logging (no secrets)
   - SNS topic permissions

## Quick Start

### Run Security Scan

```bash
# Dependency vulnerability scan
npm audit

# Fix vulnerabilities
npm audit fix

# Check for high-severity issues
npm audit --audit-level=high

# Secrets scanning (install gitleaks first)
gitleaks detect --source . --verbose
```

## Core Workflows

### Workflow 1: OWASP Top 10 Security Check

#### 1. Injection Prevention (A03:2021)

**SQL Injection:**

```javascript
// ❌ CRITICAL VULNERABILITY: SQL Injection
const username = req.query.username;
await query(`SELECT * FROM users WHERE username = '${username}'`);
// Attacker input: username=admin' OR '1'='1

// ✅ SECURE: Parameterized queries
const username = req.query.username;
await query('SELECT * FROM users WHERE username = $1', [username]);
```

**NoSQL Injection (if using MongoDB):**

```javascript
// ❌ VULNERABLE
User.find({ username: req.body.username });
// Attacker: { "username": { "$gt": "" } }

// ✅ SECURE: Type validation
const username = String(req.body.username);
User.find({ username });
```

**Command Injection:**

```javascript
// ❌ CRITICAL VULNERABILITY
const filename = req.query.file;
exec(`cat ${filename}`);

// ✅ SECURE: Never execute user input
// Use allowlist validation instead
const allowedFiles = ['file1.txt', 'file2.txt'];
if (allowedFiles.includes(filename)) {
  fs.readFile(filename, 'utf8', callback);
}
```

#### 2. Broken Authentication (A07:2021)

**API Key Security:**

```javascript
// ❌ VULNERABLE: Plain text storage
await query(
  'INSERT INTO api_keys (user_id, key) VALUES ($1, $2)',
  [userId, apiKey]
);

// ✅ SECURE: Bcrypt hashing
const keyHash = await bcrypt.hash(apiKey, 10);
await query(
  'INSERT INTO api_keys (user_id, key_hash, key_prefix) VALUES ($1, $2, $3)',
  [userId, keyHash, apiKey.substring(0, 7)]
);

// ✅ SECURE: Timing-safe comparison
for (const row of rows) {
  const isMatch = await bcrypt.compare(apiKey, row.key_hash);
  if (isMatch) {
    return row;
  }
}
```

**JWT Token Validation:**

```javascript
// ❌ VULNERABLE: No token verification
const token = req.headers.authorization?.split(' ')[1];
const decoded = jwt.decode(token); // NEVER USE decode() alone!

// ✅ SECURE: Proper verification with Clerk
const { verifyToken } = require('@clerk/clerk-sdk-node');

try {
  const payload = await verifyToken(token, {
    secretKey: process.env.CLERK_SECRET_KEY,
  });
  req.user = payload;
} catch (error) {
  return res.status(401).json({ error: 'Invalid token' });
}
```

**Session Security:**

```javascript
// ✅ SECURE: Session configuration
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,      // Prevents XSS access
    secure: true,        // HTTPS only
    sameSite: 'strict',  // CSRF protection
    maxAge: 3600000,     // 1 hour
  }
}));
```

#### 3. Sensitive Data Exposure (A02:2021)

**API Key Display:**

```javascript
// ❌ VULNERABLE: Exposing full key
res.json({
  keys: user.apiKeys.map(k => ({
    id: k.id,
    key: k.key_hash, // NEVER EXPOSE!
  }))
});

// ✅ SECURE: Only show prefix
res.json({
  keys: user.apiKeys.map(k => ({
    id: k.id,
    name: k.name,
    prefix: k.key_prefix,
    last_used: k.last_used_at,
    // NEVER include key_hash
  }))
});
```

**Error Messages:**

```javascript
// ❌ VULNERABLE: Leaking sensitive information
catch (error) {
  res.status(500).json({
    error: error.message, // May contain database details!
    stack: error.stack,   // NEVER EXPOSE STACK TRACES!
  });
}

// ✅ SECURE: Generic error messages
catch (error) {
  console.error('Internal error:', error); // Log internally only

  res.status(500).json({
    success: false,
    error: 'An error occurred. Please try again.',
    // NO technical details to client
  });
}
```

**Logging Security:**

```javascript
// ❌ VULNERABLE: Logging sensitive data
winston.info('User login', {
  username: user.username,
  password: user.password, // NEVER LOG PASSWORDS!
  apiKey: req.headers['x-api-key'], // NEVER LOG API KEYS!
});

// ✅ SECURE: Redact sensitive fields
winston.info('User login', {
  userId: user.id,
  username: user.username,
  // NO passwords, API keys, tokens
});
```

#### 4. XML External Entities (XXE) - N/A for ReachstreamAPI
*Not applicable - no XML parsing in this codebase*

#### 5. Broken Access Control (A01:2021)

**Multi-Tenant Isolation:**

```javascript
// ❌ CRITICAL VULNERABILITY: No user isolation
app.get('/api/requests', async (req, res) => {
  const requests = await query('SELECT * FROM api_requests');
  // Returns ALL users' requests!
  res.json(requests);
});

// ✅ SECURE: Enforce user isolation
app.get('/api/requests', verifyApiKey, async (req, res) => {
  const requests = await query(
    'SELECT * FROM api_requests WHERE user_id = $1',
    [req.user.id] // ALWAYS filter by authenticated user
  );
  res.json(requests);
});
```

**Authorization Checks:**

```javascript
// ❌ VULNERABLE: Missing authorization
app.delete('/api/keys/:id', verifyApiKey, async (req, res) => {
  await query('DELETE FROM api_keys WHERE id = $1', [req.params.id]);
  // Anyone can delete any key!
});

// ✅ SECURE: Verify ownership
app.delete('/api/keys/:id', verifyApiKey, async (req, res) => {
  const key = await query(
    'SELECT user_id FROM api_keys WHERE id = $1',
    [req.params.id]
  );

  if (!key.rows[0] || key.rows[0].user_id !== req.user.id) {
    return res.status(403).json({ error: 'Unauthorized' });
  }

  await query('DELETE FROM api_keys WHERE id = $1', [req.params.id]);
});
```

#### 6. Security Misconfiguration (A05:2021)

**CORS Configuration:**

```javascript
// ❌ VULNERABLE: Wide-open CORS
app.use(cors({
  origin: '*', // Allows ANY origin!
}));

// ✅ SECURE: Whitelist specific origins
app.use(cors({
  origin: [
    'https://app.reachstream.com',
    'https://dashboard.reachstream.com',
    process.env.NODE_ENV === 'development' ? 'http://localhost:5173' : null
  ].filter(Boolean),
  credentials: true,
}));
```

**Security Headers:**

```javascript
// ✅ SECURE: Helmet.js configuration
const helmet = require('helmet');

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true,
  },
}));
```

**Environment Variables:**

```javascript
// ❌ VULNERABLE: Default credentials
const dbPassword = process.env.DB_PASSWORD || 'password123';

// ✅ SECURE: Require all secrets
const requiredEnvVars = [
  'DATABASE_URL',
  'CLERK_SECRET_KEY',
  'STRIPE_SECRET_KEY',
  'OXYLABS_PASSWORD',
  'JWT_SECRET',
];

requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
});
```

#### 7. Cross-Site Scripting (XSS) - A03:2021

**Output Sanitization:**

```javascript
// ❌ VULNERABLE: Unsanitized HTML
res.send(`<h1>Welcome ${req.query.name}</h1>`);
// Attacker: name=<script>alert('XSS')</script>

// ✅ SECURE: Use JSON responses (auto-escaped)
res.json({ message: `Welcome ${req.query.name}` });

// ✅ SECURE: HTML escaping if needed
const escapeHtml = (str) => {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
};
```

**React XSS Prevention:**

```javascript
// ❌ VULNERABLE: dangerouslySetInnerHTML
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// ✅ SECURE: Use React's built-in escaping
<div>{userInput}</div>

// ✅ SECURE: If HTML needed, use DOMPurify
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{
  __html: DOMPurify.sanitize(userInput)
}} />
```

#### 8. Insecure Deserialization (A08:2021)

**JSON Parsing:**

```javascript
// ❌ VULNERABLE: Parsing untrusted data without validation
const data = JSON.parse(req.body.data);
eval(data.code); // NEVER USE EVAL!

// ✅ SECURE: Validate after parsing
const data = JSON.parse(req.body.data);

// Validate structure
const schema = {
  name: 'string',
  age: 'number',
};

for (const [key, type] of Object.entries(schema)) {
  if (typeof data[key] !== type) {
    throw new Error(`Invalid ${key}`);
  }
}
```

#### 9. Using Components with Known Vulnerabilities (A06:2021)

**Dependency Management:**

```bash
# Check for vulnerabilities
npm audit

# Update dependencies
npm update

# Check for outdated packages
npm outdated

# Use npm-check-updates for major updates
npx npm-check-updates -u
npm install
```

**Lock File Security:**

```bash
# Always commit lock files
git add package-lock.json

# Verify integrity on install
npm ci # Uses package-lock.json exactly
```

#### 10. Insufficient Logging & Monitoring (A09:2021)

**Security Event Logging:**

```javascript
// ✅ SECURE: Log security events
const logSecurityEvent = (event, details) => {
  winston.warn('Security event', {
    event,
    timestamp: new Date().toISOString(),
    userId: details.userId,
    ip: details.ip,
    userAgent: details.userAgent,
    // NO sensitive data (passwords, tokens, etc.)
  });

  // Send to Sentry for critical events
  if (['auth_failure', 'unauthorized_access'].includes(event)) {
    Sentry.captureMessage(`Security: ${event}`, {
      level: 'warning',
      extra: details,
    });
  }
};

// Log failed auth attempts
app.post('/login', async (req, res) => {
  const result = await authenticate(req.body);

  if (!result.success) {
    logSecurityEvent('auth_failure', {
      userId: req.body.username,
      ip: req.ip,
      userAgent: req.headers['user-agent'],
    });
  }
});
```

### Workflow 2: Payment Security (Stripe)

**Webhook Signature Verification:**

```javascript
// ❌ CRITICAL VULNERABILITY: No signature verification
app.post('/api/webhooks/stripe', async (req, res) => {
  const event = req.body; // Attacker can forge this!
  await handlePayment(event);
});

// ✅ SECURE: Verify Stripe signature
app.post('/api/webhooks/stripe',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    const signature = req.headers['stripe-signature'];

    try {
      const event = stripe.webhooks.constructEvent(
        req.body,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET
      );

      await handlePayment(event);
      res.json({ received: true });
    } catch (error) {
      console.error('Webhook signature verification failed:', error);
      return res.status(400).json({ error: 'Invalid signature' });
    }
  }
);
```

**Credit Transaction Integrity:**

```javascript
// ✅ SECURE: Atomic credit transactions
const addCredits = async (userId, amount, purchaseId) => {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Check for duplicate purchase
    const existing = await client.query(
      'SELECT id FROM credit_purchases WHERE stripe_payment_intent_id = $1',
      [purchaseId]
    );

    if (existing.rows.length > 0) {
      await client.query('ROLLBACK');
      throw new Error('Duplicate purchase detected');
    }

    // Add credits
    await client.query(
      'UPDATE users SET credits_balance = credits_balance + $1 WHERE id = $2',
      [amount, userId]
    );

    // Log purchase
    await client.query(
      'INSERT INTO credit_purchases (user_id, amount, credits_purchased, stripe_payment_intent_id, status) VALUES ($1, $2, $3, $4, $5)',
      [userId, purchaseAmount, amount, purchaseId, 'completed']
    );

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};
```

### Workflow 3: Rate Limiting & DDoS Protection

**API Rate Limiting:**

```javascript
// ✅ SECURE: Rate limiting per API key
const rateLimit = require('express-rate-limit');

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // 1000 requests per window
  keyGenerator: (req) => {
    // Rate limit per API key, not IP
    return req.apiKey?.id || req.ip;
  },
  handler: (req, res) => {
    res.status(429).json({
      success: false,
      error: 'Too many requests',
      message: 'Rate limit exceeded. Please try again later.',
    });
  },
});

app.use('/api/scrape', apiLimiter);
```

**Scraping Rate Limiting:**

```javascript
// ✅ SECURE: Rate limit scraping targets
const rateLimit = new Map();

const checkScrapingRateLimit = (platform, identifier) => {
  const key = `${platform}:${identifier}`;
  const now = Date.now();
  const limit = 10; // requests per minute
  const window = 60 * 1000; // 1 minute

  if (!rateLimit.has(key)) {
    rateLimit.set(key, []);
  }

  const requests = rateLimit.get(key).filter(time => now - time < window);

  if (requests.length >= limit) {
    throw new Error('Scraping rate limit exceeded. Please wait before retrying.');
  }

  requests.push(now);
  rateLimit.set(key, requests);
};
```

### Workflow 4: Secrets Management

**Environment Variable Security:**

```javascript
// ✅ SECURE: Never commit .env file
// Add to .gitignore
.env
.env.local
.env.*.local

// ✅ SECURE: Use AWS Secrets Manager for production
const { SecretsManagerClient, GetSecretValueCommand } = require('@aws-sdk/client-secrets-manager');

const getSecret = async (secretName) => {
  const client = new SecretsManagerClient({ region: 'us-east-1' });

  try {
    const response = await client.send(
      new GetSecretValueCommand({ SecretId: secretName })
    );
    return JSON.parse(response.SecretString);
  } catch (error) {
    console.error('Failed to retrieve secret:', error);
    throw error;
  }
};

// Load secrets at startup
if (process.env.NODE_ENV === 'production') {
  const secrets = await getSecret('reachstream-api-secrets');
  process.env.DATABASE_URL = secrets.DATABASE_URL;
  process.env.STRIPE_SECRET_KEY = secrets.STRIPE_SECRET_KEY;
}
```

**Oxylabs Credentials:**

```javascript
// ❌ VULNERABLE: Hardcoded credentials
const proxyUrl = 'http://scraping2025_rcOoG:password123@pr.oxylabs.io:7777';

// ✅ SECURE: Environment variables
const proxyUrl = `http://${process.env.OXYLABS_USERNAME}:${process.env.OXYLABS_PASSWORD}@${process.env.OXYLABS_HOST}:${process.env.OXYLABS_PORT}`;

// Validate credentials exist
if (!process.env.OXYLABS_PASSWORD) {
  throw new Error('OXYLABS_PASSWORD not configured');
}
```

### Workflow 5: Input Validation

**Comprehensive Validation:**

```javascript
// ✅ SECURE: Validate all inputs
const { body, query, param, validationResult } = require('express-validator');

app.post('/api/scrape/tiktok/profile',
  verifyApiKey,
  [
    query('username')
      .isString()
      .trim()
      .isLength({ min: 1, max: 100 })
      .matches(/^[a-zA-Z0-9._]+$/)
      .withMessage('Invalid username format'),
  ],
  async (req, res) => {
    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array(),
      });
    }

    // Proceed with validated input
  }
);
```

**Allowlist Validation:**

```javascript
// ✅ SECURE: Allowlist for enum-like values
const allowedSortOptions = ['hot', 'new', 'top', 'rising'];

const sort = req.query.sort || 'hot';

if (!allowedSortOptions.includes(sort)) {
  return res.status(400).json({
    success: false,
    error: `Invalid sort option. Must be one of: ${allowedSortOptions.join(', ')}`,
  });
}
```

## Best Practices

### 1. Defense in Depth

Implement multiple layers of security:

- **Network:** HTTPS, CORS, Rate limiting
- **Application:** Input validation, Authentication, Authorization
- **Data:** Encryption at rest and in transit, Parameterized queries
- **Infrastructure:** AWS security groups, Lambda permissions, VPC

### 2. Principle of Least Privilege

```javascript
// ✅ Lambda execution role with minimal permissions
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue"
      ],
      "Resource": "arn:aws:secretsmanager:us-east-1:*:secret:reachstream-api-*"
    }
  ]
}
```

### 3. Security by Default

```javascript
// ✅ Secure defaults
const DEFAULT_CONFIG = {
  cors: {
    origin: [], // No origins by default
    credentials: true,
  },
  session: {
    httpOnly: true,
    secure: true, // HTTPS only
    sameSite: 'strict',
  },
  rateLimit: {
    enabled: true,
    max: 100,
  },
};
```

### 4. Fail Securely

```javascript
// ✅ Default to secure state on error
try {
  const hasPermission = await checkPermission(userId, resource);
  if (hasPermission) {
    return allowAccess();
  }
} catch (error) {
  console.error('Permission check failed:', error);
  // On error, DENY access (fail closed)
  return denyAccess();
}
```

## Security Checklist

### Pre-Deployment Security Audit

#### Authentication & Authorization
- [ ] All endpoints require authentication
- [ ] API keys hashed with bcrypt (10+ rounds)
- [ ] JWT tokens verified with Clerk
- [ ] Multi-tenant data isolated by user_id
- [ ] Authorization checks on all resources
- [ ] No default credentials

#### Data Protection
- [ ] All database queries parameterized
- [ ] No SQL injection vulnerabilities
- [ ] Secrets in environment variables (not code)
- [ ] .env file in .gitignore
- [ ] No API keys in logs or error messages
- [ ] PII filtered from error tracking (Sentry)
- [ ] HTTPS enforced in production

#### Input Validation
- [ ] All user input validated
- [ ] Allowlist validation for enum values
- [ ] Length limits on all string inputs
- [ ] Type checking on all inputs
- [ ] No eval() or Function() with user input

#### Error Handling
- [ ] Generic error messages to clients
- [ ] Detailed errors logged internally only
- [ ] No stack traces exposed
- [ ] Security events logged
- [ ] Failed login attempts tracked

#### Third-Party Services
- [ ] Stripe webhook signatures verified
- [ ] Oxylabs credentials in environment
- [ ] Clerk tokens properly verified
- [ ] Rate limiting on external API calls
- [ ] Retry logic with exponential backoff

#### Infrastructure
- [ ] Lambda IAM roles minimal permissions
- [ ] Security groups properly configured
- [ ] CloudWatch logs don't contain secrets
- [ ] S3 buckets not publicly accessible
- [ ] API Gateway authorization enabled

#### Dependencies
- [ ] npm audit shows no high/critical issues
- [ ] All dependencies up to date
- [ ] package-lock.json committed
- [ ] No known vulnerabilities

#### Headers & Configuration
- [ ] Helmet.js configured
- [ ] CORS properly restricted
- [ ] CSP headers set
- [ ] HSTS enabled
- [ ] X-Content-Type-Options: nosniff

### Continuous Security

#### Daily
- [ ] Monitor CloudWatch for unusual patterns
- [ ] Check Sentry for new error types
- [ ] Review failed authentication attempts

#### Weekly
- [ ] Run npm audit
- [ ] Review access logs
- [ ] Check rate limiting metrics

#### Monthly
- [ ] Update dependencies
- [ ] Security audit of new features
- [ ] Review IAM permissions
- [ ] Rotate API keys (if compromised)

#### Quarterly
- [ ] Penetration testing
- [ ] Security training for team
- [ ] Incident response drill
- [ ] Third-party security audit

## Common Vulnerabilities & Fixes

### 1. API Key Leakage

**Vulnerability:**
```javascript
// ❌ API key visible in client-side code
fetch('https://api.example.com/data', {
  headers: {
    'X-API-Key': 'rsk_live_abc123...' // EXPOSED TO ALL USERS!
  }
});
```

**Fix:**
```javascript
// ✅ API key on server-side only
// Client authenticates with Clerk
// Server uses API key internally
const result = await fetch('https://api.reachstream.com/internal', {
  headers: {
    'Authorization': `Bearer ${clerkToken}`, // User token
  }
});
```

### 2. Credit Balance Manipulation

**Vulnerability:**
```javascript
// ❌ Client controls credit deduction
const creditsUsed = req.body.creditsUsed; // Attacker sends 0!
await query(
  'UPDATE users SET credits_balance = credits_balance - $1 WHERE id = $2',
  [creditsUsed, userId]
);
```

**Fix:**
```javascript
// ✅ Server calculates credits
const CREDITS_PER_REQUEST = 1; // Fixed on server
await query(
  'UPDATE users SET credits_balance = credits_balance - $1 WHERE id = $2',
  [CREDITS_PER_REQUEST, userId]
);
```

### 3. Insecure Direct Object Reference (IDOR)

**Vulnerability:**
```javascript
// ❌ No ownership check
app.get('/api/keys/:id', verifyApiKey, async (req, res) => {
  const key = await query(
    'SELECT * FROM api_keys WHERE id = $1',
    [req.params.id]
  );
  res.json(key.rows[0]); // Returns ANY user's key!
});
```

**Fix:**
```javascript
// ✅ Verify ownership
app.get('/api/keys/:id', verifyApiKey, async (req, res) => {
  const key = await query(
    'SELECT * FROM api_keys WHERE id = $1 AND user_id = $2',
    [req.params.id, req.user.id]
  );

  if (!key.rows[0]) {
    return res.status(404).json({ error: 'Key not found' });
  }

  res.json(key.rows[0]);
});
```

## Incident Response

### Security Incident Procedure

1. **Detect:** Monitor alerts (Sentry, CloudWatch)
2. **Contain:** Disable compromised API keys/accounts
3. **Investigate:** Review logs, identify scope
4. **Remediate:** Fix vulnerability, patch systems
5. **Recover:** Restore service, verify fix
6. **Learn:** Post-mortem, update procedures

### Breach Response

If API keys or secrets are compromised:

```bash
# 1. Rotate all secrets immediately
# 2. Revoke compromised API keys
UPDATE api_keys SET is_active = false WHERE key_prefix IN ('compromised_prefixes');

# 3. Audit access logs
SELECT * FROM api_requests
WHERE api_key_id IN (SELECT id FROM api_keys WHERE key_prefix = 'compromised')
AND created_at > '2024-01-01';

# 4. Notify affected users
# 5. Update monitoring for suspicious activity
```

## Advanced Topics

### API Security Testing

```bash
# OWASP ZAP for vulnerability scanning
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t https://api.reachstream.com

# SQL injection testing
sqlmap -u "https://api.reachstream.com/api/scrape/tiktok/profile?username=test" \
  --headers="X-API-Key: test_key"

# Load testing for DDoS resilience
artillery run load-test.yml
```

### Security Headers Testing

```bash
# Check security headers
curl -I https://api.reachstream.com

# Should see:
# Strict-Transport-Security: max-age=31536000; includeSubDomains
# X-Content-Type-Options: nosniff
# X-Frame-Options: DENY
# Content-Security-Policy: default-src 'self'
```

## Reference

For complete security guidelines, see:
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)
- [Express Security](https://expressjs.com/en/advanced/best-practice-security.html)
